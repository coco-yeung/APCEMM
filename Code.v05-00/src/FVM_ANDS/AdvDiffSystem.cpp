#include <FVM_ANDS/AdvDiffSystem.hpp>
#include <chrono>
#include <math.h>
#include <iostream>
#include <variant>
#include "APCEMM.h"

namespace FVM_ANDS{
    AdvDiffSystem::AdvDiffSystem(const AdvDiffParams& params, const Vector_1D xCoords, const Vector_1D yCoords, const BoundaryConditions& bc, const Eigen::VectorXd& phi_init, vecFormat format) :
        format_(format),
        u_double_ (params.u),
        v_double_ (params.v),
        shear_ (params.shear),
        dt_ (params.dt),
        dx_ (xCoords[1] - xCoords[0]),
        dy_ (yCoords[1] - yCoords[0]),
        nx_ (xCoords.size()),
        ny_ (yCoords.size()),
        yCoord_(yCoords),
        bcType_top_ (bc.bcType_top),
        bcType_left_ (bc.bcType_left),
        bcType_right_ (bc.bcType_right),
        bcType_bot_ (bc.bcType_bot),
        bcVals_top_ (bc.bcVals_top),
        bcVals_left_ (bc.bcVals_left),
        bcVals_right_ (bc.bcVals_right),
        bcVals_bot_ (bc.bcVals_bot),
        phi_(phi_init)
    {
        invdx_ = 1.0/dx_;
        invdy_ = 1.0/dy_;
        nInteriorPoints_ = nx_ * ny_;
        nGhostPoints_ = 2*nx_ + 2*ny_;
        nTotalPoints_ = nInteriorPoints_ + nGhostPoints_;

        u_vec_.resize(nInteriorPoints_);
        v_vec_.resize(nInteriorPoints_);
        Dh_vec_.resize(nInteriorPoints_);
        Dv_vec_.resize(nInteriorPoints_);
        rhs_.resize(nTotalPoints_);
        phi_.resize(nTotalPoints_);
        deferredCorr_.resize(nInteriorPoints_);
        deferredCorr_.setZero();
        source_.resize(nInteriorPoints_);
        source_.setZero();
        
        std::generate_n(std::back_inserter(points_), nTotalPoints_, [] { 
            return Point();  // Construct directly in vector
        });
        totalCoefMatrix_.resize(nTotalPoints_, nTotalPoints_);

        #ifdef ENABLE_TIMING
        auto start = std::chrono::high_resolution_clock::now();
        #endif
        updateDiffusion(params.Dh, params.Dv);
        #ifdef ENABLE_TIMING
        auto end = std::chrono::high_resolution_clock::now();
        auto duration_us = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        std::cout << "          AdvDiffSys Construtor: updateDiff " << duration_us.count() << " us" << std::endl;

        start = std::chrono::high_resolution_clock::now();
        #endif
        initVelocVecs();
        #ifdef ENABLE_TIMING
        end = std::chrono::high_resolution_clock::now();
        duration_us = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        std::cout << "          AdvDiffSys Construtor: initVelocVecs " << duration_us.count() << " us" << std::endl;

        start = std::chrono::high_resolution_clock::now();
        #endif
        buildPointList();
        #ifdef ENABLE_TIMING
        end = std::chrono::high_resolution_clock::now();
        duration_us = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        std::cout << "          AdvDiffSys Construtor: buildPointList " << duration_us.count() << " us" << std::endl;

        start = std::chrono::high_resolution_clock::now();
        #endif
        applyBoundaryCondition();
        #ifdef ENABLE_TIMING
        end = std::chrono::high_resolution_clock::now();
        duration_us = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        std::cout << "          AdvDiffSys Construtor: applyBoundaryCondition " << duration_us.count() << " us" << std::endl;

        start = std::chrono::high_resolution_clock::now();
        #endif
    }

    void AdvDiffSystem::initVelocVecs(){
        for(int i = 0; i < nx_; i++){
            for(int j = 0; j < ny_; j++){
                int vector_idx = twoDIdx_to_vecIdx(i, j, nx_, ny_, format_);
                u_vec_[vector_idx] = u_double_ - yCoord_[j] * shear_;
                v_vec_[vector_idx] = v_double_;
            }
        }
    }

    void AdvDiffSystem::buildPointList(){
        //interior points
        for(int i = 0; i < nx_; i++){
            for(int j = 0; j < ny_; j++){
                int vector_idx = twoDIdx_to_vecIdx(i, j, nx_, ny_, format_);
                //top interior bound / ghost points
                if(j == ny_ - 1){
                    BoundaryCondDescription bc_ghost = BoundaryCondDescription(bcType_top_, FaceDirection::NORTH, bcVals_top_[i], vector_idx);
                    int corrGhostPoint = nInteriorPoints_ + i;
                    points_[corrGhostPoint] = GhostPoint{bc_ghost};

                    BoundaryCondDescription bc_top = BoundaryCondDescription(bcType_top_, FaceDirection::NORTH, bcVals_top_[i], corrGhostPoint);

                    //check for top corner point edge cases
                    //top left
                    if(i == 0){
                        int corrGhostPoint2 = nInteriorPoints_ + nx_ + j;
                        BoundaryCondDescription bc_left = BoundaryCondDescription(bcType_left_, FaceDirection::WEST, bcVals_left_[j], corrGhostPoint2);
                        BoundaryCondDescription bc_ghost2 = BoundaryCondDescription(bcType_left_, FaceDirection::WEST, bcVals_left_[j], vector_idx);
                        points_[vector_idx] = IntBoundPoint(bc_top, bc_left);
                        points_[corrGhostPoint2] = GhostPoint(bc_ghost2);
                    }
                    //top right
                    else if(i == nx_ - 1){
                        int corrGhostPoint2 = nInteriorPoints_ + nx_ + ny_ + j;
                        BoundaryCondDescription bc_right = BoundaryCondDescription(bcType_right_, FaceDirection::EAST, bcVals_right_[j], corrGhostPoint2);
                        BoundaryCondDescription bc_ghost2 = BoundaryCondDescription(bcType_right_, FaceDirection::EAST, bcVals_right_[j], vector_idx);
                        points_[vector_idx] = IntBoundPoint(bc_top, bc_right);
                        points_[corrGhostPoint2] = GhostPoint(bc_ghost2);
                    }
                    //if not corner boundary make normal interior node.
                    else{
                        points_[vector_idx] = IntBoundPoint(bc_top);
                    }
                }
                //bottom 
                else if (j == 0){
                    int corrGhostPoint = nInteriorPoints_ + nx_ + 2*ny_ + i;
                    BoundaryCondDescription bc_ghost = BoundaryCondDescription(bcType_bot_, FaceDirection::SOUTH, bcVals_bot_[i], vector_idx);
                    points_[corrGhostPoint] = GhostPoint(bc_ghost);

                    BoundaryCondDescription bc_bot = BoundaryCondDescription(bcType_bot_, FaceDirection::SOUTH, bcVals_bot_[i], corrGhostPoint);

                    //check for bottom edge cases
                    //bot left
                    if(i == 0){
                        int corrGhostPoint2 = nInteriorPoints_ + nx_ + j;

                        BoundaryCondDescription bc_left = BoundaryCondDescription(bcType_left_, FaceDirection::WEST, bcVals_left_[j], corrGhostPoint2);
                        BoundaryCondDescription bc_ghost2 = BoundaryCondDescription(bcType_left_, FaceDirection::WEST, bcVals_left_[j], vector_idx);
                        
                        points_[vector_idx] = IntBoundPoint(bc_bot, bc_left);
                        points_[corrGhostPoint2] = GhostPoint(bc_ghost2);
                    }
                    //bot right
                    else if(i == nx_ - 1){
                        int corrGhostPoint2 = nInteriorPoints_ + nx_ + ny_ + j;
                        BoundaryCondDescription bc_right = BoundaryCondDescription(bcType_right_, FaceDirection::EAST, bcVals_right_[j], corrGhostPoint2);
                        BoundaryCondDescription bc_ghost2 = BoundaryCondDescription(bcType_right_, FaceDirection::EAST, bcVals_right_[j], vector_idx);
                        
                        points_[vector_idx] = IntBoundPoint(bc_bot, bc_right);
                        points_[corrGhostPoint2] = GhostPoint(bc_ghost2);

                    }
                    //if not corner boundary make normal interior node
                    else {
                        points_[vector_idx] = IntBoundPoint(bc_bot);
                    }

                }
                // left
                else if (i == 0){
                    int corrGhostPoint = nInteriorPoints_ + nx_ + j;
                    BoundaryCondDescription bc_left = BoundaryCondDescription(bcType_left_, FaceDirection::WEST, bcVals_left_[j], corrGhostPoint);
                    BoundaryCondDescription bc_ghost = BoundaryCondDescription(bcType_left_, FaceDirection::WEST, bcVals_left_[j], vector_idx);

                    points_[vector_idx] = IntBoundPoint(bc_left);
                    points_[corrGhostPoint] = GhostPoint(bc_ghost);
                } 
                //right 
                else if (i == nx_ - 1){
                    int corrGhostPoint = nInteriorPoints_ + nx_ + ny_ + j;
                    BoundaryCondDescription bc_right = BoundaryCondDescription(bcType_right_, FaceDirection::EAST, bcVals_right_[j], corrGhostPoint);
                    BoundaryCondDescription bc_ghost = BoundaryCondDescription(bcType_right_, FaceDirection::EAST, bcVals_right_[j], vector_idx);

                    points_[vector_idx] = IntBoundPoint(bc_right);
                    points_[corrGhostPoint] = GhostPoint(bc_ghost);
                }
                else {
                    points_[vector_idx] = Point(BoundaryConditionFlag::INTERIOR);
                }
            }
        }
    }
    void AdvDiffSystem::buildCoeffMatrix(bool operatorSplit){
        // Skip if we have a prebuilt matrix
        if (use_shared_totalCoefMatrix_) {
            return;
        }
        
        //Crank-Nicholson Discretization. Builds the Advection terms of the A matrix 
        //in the system A * phi_t+1 = b.

        //Num non-zeros calculation: 
        std::vector<Eigen::Triplet<double>> tripletList;
        auto start = std::chrono::high_resolution_clock::now();
        for(int i = 0; i < nTotalPoints_; i++){
            bool isGhost = std::visit([](const auto& p) { return p.isGhost(); }, points_[i]);
            if(isGhost){
                visitPoint(i, [&](auto& point) {
                    switch(point.bcType()){
                        case BoundaryConditionFlag::DIRICHLET_GHOSTPOINT:{
                            // (phi_int + phi_ghost) / 2 = phi_boundary
                            // if inhomog, the bc value will appear in the rhs.
                            tripletList.emplace_back(i, i, 0.5);
                            tripletList.emplace_back(i, point.corrPoint(), 0.5);
                            break;
                        }
                        case BoundaryConditionFlag::PERIODIC_GHOSTPOINT:{
                            // Ghost node will exactly equal to the cell on the other end of the domain
                            // effectively makes opposite ends of the domain neighbor points.
                            throw std::runtime_error("Periodic BCs not yet implemented.");
                            break;
                        }
                        default: {
                            throw std::runtime_error("Ghost point doesn't have a bcType associated with being a ghost point!");
                        }
                    }
                });
                continue;
            }

            int idx_E = neighbor_point(FaceDirection::EAST, i);
            int idx_W = neighbor_point(FaceDirection::WEST, i);
            int idx_N = neighbor_point(FaceDirection::NORTH, i);
            int idx_S = neighbor_point(FaceDirection::SOUTH, i);

            //Diffusion Terms
            double coeff_C = 1 + 2 * dt_ * (Dh_vec_[i] / (dx_ * dx_) + Dv_vec_[i] / (dy_ * dy_));
            double coeff_E = -Dh_vec_[i] * dt_ / (dx_ * dx_);
            double coeff_W = -Dh_vec_[i] * dt_ / (dx_ * dx_) ;
            double coeff_N = -Dv_vec_[i] * dt_ / (dy_ * dy_);
            double coeff_S = -Dv_vec_[i] * dt_ / (dy_ * dy_);

            //Operator splitting uses implicit only for diffusion
            if(!operatorSplit && (u_double_ > 0 || v_double_ > 0 || shear_ > 0)){
                buildAdvectionCoeffs(i, coeff_C, coeff_N, coeff_S, coeff_E, coeff_W);
            }

            //Triplet Format: row, col, value
            tripletList.emplace_back(i, idx_E, coeff_E);
            tripletList.emplace_back(i, idx_W, coeff_W);
            tripletList.emplace_back(i, idx_N, coeff_N);
            tripletList.emplace_back(i, idx_S, coeff_S);
            tripletList.emplace_back(i, i, coeff_C);
        } 

        auto stop = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop-start);
        totalCoefMatrix_.setFromTriplets(tripletList.begin(), tripletList.end());
    }
    void AdvDiffSystem::buildAdvectionCoeffs(int i, double& coeff_C, double& coeff_N, double& coeff_S, double& coeff_E, double& coeff_W){
        //Advection Terms
        //When a boundary condition is in place, phi at the face can be directly calculated using the BC.
        //Therefore, that term goes to the RHS and the contribution of that face to the coeffs goes to 0.

        bool isNorthBoundary = 0, isWestBoundary = 0, isEastBoundary = 0, isSouthBoundary = 0;
        visitPoint(i, [&](auto& point) {
            if(point.bcType() != BoundaryConditionFlag::INTERIOR){
            isNorthBoundary = point.bcDirection() == FaceDirection::NORTH;
            isSouthBoundary = point.bcDirection() == FaceDirection::SOUTH;

            //Corner cases...
            bool secondaryWestBound = (point.secondBoundaryConds() && point.secondBoundaryConds().value().direction == FaceDirection::WEST);
            bool secondaryEastBound = (point.secondBoundaryConds() && point.secondBoundaryConds().value().direction == FaceDirection::EAST);

            isWestBoundary = (point.bcDirection() == FaceDirection::WEST || secondaryWestBound);
            isEastBoundary = (point.bcDirection() == FaceDirection::EAST || secondaryEastBound);
            }
        });

        int idx_E = neighbor_point(FaceDirection::EAST, i);
        int idx_W = neighbor_point(FaceDirection::WEST, i);
        int idx_N = neighbor_point(FaceDirection::NORTH, i);
        int idx_S = neighbor_point(FaceDirection::SOUTH, i);

        double u_W = isWestBoundary? u_vec_[i] : 0.5 * (u_vec_[i] + u_vec_[idx_W]);
        double u_E = isEastBoundary? u_vec_[i] : 0.5 * (u_vec_[i] + u_vec_[idx_E]);
        double v_N = isNorthBoundary? v_vec_[i] : 0.5 * (v_vec_[i] + v_vec_[idx_N]);
        double v_S = isSouthBoundary? v_vec_[i] : 0.5 * (v_vec_[i] + v_vec_[idx_S]);

        if (u_E >= 0) coeff_C += u_E * dt_ / dx_;
        if (u_W < 0) coeff_C -= u_W * dt_ / dx_;
        if (v_N >= 0) coeff_C += v_N * dt_ / dy_;
        if (v_S < 0) coeff_C -= v_S * dt_ / dy_;

        if (u_E < 0) coeff_E += u_E * dt_ / dy_;

        if (u_W >= 0) coeff_W -= u_W * dt_ / dx_;

        if (v_N < 0) coeff_N += v_N * dt_ / dy_;

        if (v_S >= 0) coeff_S -= v_S * dt_ / dy_;

        double phi_N_corr = 0, phi_S_corr = 0, phi_W_corr = 0, phi_E_corr = 0;

        auto bool_to_signed = [](bool binary) { return binary ? 1 : -1; };

        if (!isNorthBoundary)
            phi_N_corr -= bool_to_signed(v_N >= 0) * v_N * dt_ / dy_ * 0.5 * minmod(i, FaceDirection::NORTH, 0) * (phi_[idx_N] - phi_[i]);

        if (!isSouthBoundary)
            phi_S_corr += bool_to_signed(v_S >= 0) * v_S * dt_ / dy_ * 0.5 * minmod(i, FaceDirection::SOUTH, 0) * (phi_[i] - phi_[idx_S]);
        
        if (!isWestBoundary)
            phi_W_corr += bool_to_signed(u_W >= 0) * u_W * dt_ / dx_ * 0.5 * minmod(i, FaceDirection::WEST, 0) * (phi_[i] - phi_[idx_W]);

        if (!isEastBoundary)
            phi_E_corr -= bool_to_signed(u_E >= 0) * u_E * dt_ / dx_ * 0.5 * minmod(i, FaceDirection::EAST, 0) * (phi_[idx_E] - phi_[i]);
        
        double TVD_deferred_corr = phi_N_corr + phi_S_corr + phi_W_corr + phi_E_corr;
        deferredCorr_[i] = TVD_deferred_corr;
    }

    const Eigen::VectorXd& AdvDiffSystem::calcRHS(){
        for(int i = 0; i < nTotalPoints_; i++){
            visitPoint(i, [&](auto& point) {
                    bool isGhost = point.isGhost();
                    auto bcTypeVal = point.bcType();
                    auto bcValVal = point.bcVal();
            
                if(isGhost){
                    switch(bcTypeVal){
                        case BoundaryConditionFlag::DIRICHLET_GHOSTPOINT:{
                            // Equation: (phi_int + phi_ghost) / 2 = phi_boundary
                            rhs_[i] = bcValVal;
                            break;
                        }
                        case BoundaryConditionFlag::PERIODIC_GHOSTPOINT:{
                            // Ghost node will exactly equal to the cell on the other end of the domain
                            // effectively makes opposite ends of the domain neighbor points.
                            throw std::runtime_error("Periodic BCs not yet implemented.");
                            break;
                        }
                        default: {
                            throw std::runtime_error("Ghost point doesn't have a bcType associated with being a ghost point!");
                        }                
                    }
                    return;
                }

                switch(bcTypeVal){
                    case BoundaryConditionFlag::INTERIOR:{
                        rhs_[i] = phi_[i] + deferredCorr_[i] + source_[i]*dt_;
                        break;
                    }
                    case BoundaryConditionFlag::DIRICHLET_INT_BPOINT:{
                        auto bcDirectionVal = point.bcDirection();
                        rhs_[i] = phi_[i] + deferredCorr_[i] + source_[i]*dt_;
                        switch(bcDirectionVal){
                            case FaceDirection::NORTH:
                                rhs_[i] -= v_vec_[i] * dt_ / dy_ * bcValVal;
                                break;
                            case FaceDirection::SOUTH:
                                rhs_[i] += v_vec_[i] * dt_ / dy_ * bcValVal;
                                break;
                            case FaceDirection::EAST:
                                rhs_[i] -= u_vec_[i] * dt_ / dx_ * bcValVal;
                                break;
                            case FaceDirection::WEST:
                                rhs_[i] += u_vec_[i] * dt_ / dx_ * bcValVal;
                                break;
                            case FaceDirection::ERROR:
                                throw std::runtime_error("Invalid FaceDirection in Dirichlet boundary condition");
                        }
                        auto secondVal = point.secondBoundaryConds();
                        if (!secondVal) break;
                        BoundaryCondDescription bc_2 = secondVal.value();
                        switch(bc_2.direction){
                            case FaceDirection::EAST:
                                rhs_[i] -= u_vec_[i] * dt_ / dx_ * bc_2.bcVal;
                                break;
                            case FaceDirection::WEST:
                                rhs_[i] += u_vec_[i] * dt_ / dx_ * bc_2.bcVal;
                                break;
                            default:
                                throw std::runtime_error("Can't have anything but EAST or WEST as secondary BC!");
                        }
                        break;
                    }
                    case BoundaryConditionFlag::PERIODIC_INT_BPOINT:{
                        throw std::runtime_error("Periodic BCs not yet implemented.");
                        break;
                    }
                    default: {
                        throw std::runtime_error("Interior boundary point has invalid bcType");
                    }                
                }
            });
            continue;
        }

        return rhs_;
    }
    void AdvDiffSystem::applyBoundaryCondition(){
        //top and bottom bc
        for(int i = 0; i < nx_; i++){
            //top
            int bPointID_top = twoDIdx_to_vecIdx(i, ny_ - 1, nx_, ny_, format_);
            switch(bcType_top_){
                case BoundaryConditionFlag::DIRICHLET_INT_BPOINT: {
                    visitPoint(bPointID_top, [&](auto& point) {
                        int ghostPointID = point.corrPoint();
                        phi_[ghostPointID] = 2 * point.bcVal() - phi_[bPointID_top];
                    });
                    break;
                }
                default: {
                    throw std::runtime_error("Chosen boundary condition not implemented yet");
                }
            }

            //bottom
            int bPointID_bot = twoDIdx_to_vecIdx(i, 0, nx_, ny_, format_);
            switch(bcType_bot_){
                case BoundaryConditionFlag::DIRICHLET_INT_BPOINT: {
                    visitPoint(bPointID_bot, [&](auto& point) {
                        int ghostPointID = point.corrPoint();
                        phi_[ghostPointID] = 2 * point.bcVal() - phi_[bPointID_bot];
                    });
                    break;
                }
                default: {
                    throw std::runtime_error("Chosen boundary condition not implemented yet");
                }
            }
        }

        //left and right bc
        for(int j = 0; j < ny_; j++){
            //corner cases
            if(j == 0 || j == ny_ - 1){
                int bPointID_cornerLeft = twoDIdx_to_vecIdx(0, j, nx_, ny_, format_);
                visitPoint(bPointID_cornerLeft, [&](auto& point) {
                    int ghostPointID = point.secondBoundaryConds().value().corrPoint;
                    double bcVal =  point.secondBoundaryConds().value().bcVal;
                
                    switch(bcType_left_){
                        case BoundaryConditionFlag::DIRICHLET_INT_BPOINT: {
                            phi_[ghostPointID] = 2 * bcVal - phi_[bPointID_cornerLeft];
                            break;
                        }
                        default: {
                            throw std::runtime_error("Chosen boundary condition not implemented yet");
                        }
                    }
                });
                int bPointID_cornerRight = twoDIdx_to_vecIdx(nx_ - 1, j, nx_, ny_, format_);
                visitPoint(bPointID_cornerRight, [&](auto& point) {
                    int ghostPointID = point.secondBoundaryConds().value().corrPoint;
                    double bcVal =  point.secondBoundaryConds().value().bcVal;
                
                    switch(bcType_right_){
                        case BoundaryConditionFlag::DIRICHLET_INT_BPOINT: {
                            phi_[ghostPointID] = 2 * bcVal - phi_[bPointID_cornerRight];
                            break;
                        }
                        default: {
                            throw std::runtime_error("Chosen boundary condition not implemented yet");
                        }
                    }
                });
            }

            //left
            int bPointID_left = twoDIdx_to_vecIdx(0, j, nx_, ny_, format_);
            switch(bcType_left_){
                case BoundaryConditionFlag::DIRICHLET_INT_BPOINT: {
                    visitPoint(bPointID_left, [&](auto& point) {
                        int ghostPointID = point.corrPoint();
                        phi_[ghostPointID] = 2 * point.bcVal() - phi_[bPointID_left];
                    });
                    break;
                }
                default: {
                    throw std::runtime_error("Chosen boundary condition not implemented yet");
                }
            }
            //right
            int bPointID_right = twoDIdx_to_vecIdx(nx_ - 1, j, nx_, ny_, format_);
            switch(bcType_right_){
                case BoundaryConditionFlag::DIRICHLET_INT_BPOINT: {
                    visitPoint(bPointID_right, [&](auto& point) {
                        int ghostPointID = point.corrPoint();
                        phi_[ghostPointID] = 2 * point.bcVal() - phi_[bPointID_right];
                    });
                    break;
                }
                default: {
                    throw std::runtime_error("Chosen boundary condition not implemented yet");
                }
            }
        }
    }
    void AdvDiffSystem::updateBoundaryCondition(const BoundaryConditions& bc){
        bcType_top_ = bc.bcType_top;
        bcType_left_ = bc.bcType_left;
        bcType_right_ = bc.bcType_right;
        bcType_bot_ = bc.bcType_bot;
        bcVals_top_ = bc.bcVals_top;
        bcVals_left_ = bc.bcVals_left;
        bcVals_right_ = bc.bcVals_right;
        bcVals_bot_ = bc.bcVals_bot;

        //Go through ghost points, and update the bcType and value of them and their corresponding interior nodes
        //As seen in buildPointList(), ghost point order goes top->left->right->bottom
        int currIdx = nInteriorPoints_;
        //top
        for(int i = 0; i < nx_; i++){
            int corrPointID;
            visitPoint(currIdx, [&](auto& point) {
                corrPointID = point.corrPoint();
                point.setBCType(bcType_top_);
                point.setBCVal(bcVals_top_[i]);
            });
            visitPoint(corrPointID, [&](auto& point) {
                point.setBCType(bcType_top_);
                point.setBCVal(bcVals_top_[i]);
            });
            currIdx++;
        }
        //left
        for(int i = 0; i < ny_; i++){
            int corrPointID;
            visitPoint(currIdx, [&](auto& point) {
                corrPointID = point.corrPoint();
            });
            if(i == 0 || i == ny_ - 1){
                visitPoint(currIdx, [&](auto& point) {
                    point.setBCType(bcType_left_);
                    point.setBCVal(bcVals_left_[i]);
                });
                BoundaryCondDescription bc(bcType_left_, FaceDirection::WEST, bcVals_left_[i], currIdx);
                visitPoint(corrPointID, [&](auto& point) {
                    point.setSecondaryBC(bc);
                });
                currIdx++;
                continue;
            }
            visitPoint(currIdx, [&](auto& point) {
                point.setBCType(bcType_left_);
                point.setBCVal(bcVals_left_[i]);
            });
            visitPoint(corrPointID, [&](auto& point) {
                point.setBCType(bcType_left_);
                point.setBCVal(bcVals_left_[i]);
            });
            currIdx++;
        }
        //right
        for(int i = 0; i < ny_; i++){
            int corrPointID;
            visitPoint(currIdx, [&](auto& point) {
                corrPointID = point.corrPoint();
            });
            if(i == 0 || i == ny_ - 1){
                visitPoint(currIdx, [&](auto& point) {
                    point.setBCType(bcType_right_);
                    point.setBCVal(bcVals_right_[i]);
                });
                BoundaryCondDescription bc(bcType_right_, FaceDirection::EAST, bcVals_right_[i], currIdx);
                visitPoint(corrPointID, [&](auto& point) {
                    point.setSecondaryBC(bc);
                });
                currIdx++;
                continue;
            }
            visitPoint(currIdx, [&](auto& point) {
                point.setBCType(bcType_right_);
                point.setBCVal(bcVals_right_[i]);
            });
            visitPoint(corrPointID, [&](auto& point) {
                point.setBCType(bcType_right_);
                point.setBCVal(bcVals_right_[i]);
            });
        }
        //bot
        for(int i = 0; i < nx_; i++){
            int corrPointID;
            visitPoint(currIdx, [&](auto& point) {
                corrPointID = point.corrPoint();
                point.setBCType(bcType_bot_);
                point.setBCVal(bcVals_bot_[i]);
            });
            visitPoint(corrPointID, [&](auto& point) {
                point.setBCType(bcType_bot_);
                point.setBCVal(bcVals_bot_[i]);
            });
            currIdx++;
        }
        applyBoundaryCondition(); //need this to calculate minmod function at some timestep.
    }

    Eigen::VectorXd AdvDiffSystem::forwardEulerAdvection(bool operatorSplit, bool parallelAdvection) const noexcept{
        Eigen::VectorXd soln(nTotalPoints_);
        // double avgBackgroundCalcTime = 0;
        //Explicit Time-Stepping
        #pragma omp parallel for    \
        if      ( parallelAdvection ) \
        default ( shared          ) \
        schedule( static, 100      )
        for(int i = 0; i < nInteriorPoints_; i++){
            //When a boundary condition is in place, phi at the face can be directly calculated using the BC.
            //Therefore, that term goes to the RHS and the contribution of that face to the coeffs goes to 0.
            bool isNorthBoundary = 0, isWestBoundary = 0, isEastBoundary = 0, isSouthBoundary = 0, secondaryWestBound = 0, secondaryEastBound = 0;
            int idx_E = i + ny_;
            int idx_W = i - ny_;
            int idx_N = i + 1;
            int idx_S = i - 1;

            //commenting out this results in ~30% speedup
            //The calls involving the optional are maybe 1/3 of the cost. Maybe something to look at later.
            visitPoint(i, [&](auto& point) {
                if(point.bcType() != BoundaryConditionFlag::INTERIOR){
                    FaceDirection direction = point.bcDirection();
                    isNorthBoundary = direction == FaceDirection::NORTH;
                    isSouthBoundary = direction == FaceDirection::SOUTH;

                    auto secondBC = point.secondBoundaryConds();

                    //Corner cases...
                    bool secondaryWestBound = (secondBC && secondBC->direction == FaceDirection::WEST);
                    bool secondaryEastBound = (secondBC && secondBC->direction == FaceDirection::EAST);

                    isWestBoundary = (direction == FaceDirection::WEST || secondaryWestBound);
                    isEastBoundary = (direction == FaceDirection::EAST || secondaryEastBound);

                    //only call this lookup function on boundary nodes which are inconsequential in number
                    idx_N = isNorthBoundary? point.corrPoint() : idx_N;
                    idx_S = isSouthBoundary? point.corrPoint() : idx_S;
                    idx_E = isEastBoundary? (secondaryEastBound ? secondBC->corrPoint : point.corrPoint()) : idx_E;
                    idx_W = isWestBoundary? (secondaryEastBound ? secondBC->corrPoint : point.corrPoint()) : idx_W;
                }
                //When you declare these vars (inside or outside loop) has 0 impact)
                //takes ~ 6 out of 18 ns on background var calcs

                //these cost almost nothing to compute but commenting out anyway for maximum performance
                // double dphi_dx_E = (phi_[idx_E] - phi_[i]) * invdx_;
                // double dphi_dx_W = (phi_[i] - phi_[idx_W]) * invdx_;
                // double dphi_dy_N = (phi_[idx_N] - phi_[i]) * invdy_;
                // double dphi_dy_S = (phi_[i] - phi_[idx_S]) * invdy_;
                
                //ignoreing distinction of faces saves a good amt of time
                // double u_W = isWestBoundary? u_vec_[i] : 0.5 * (u_vec_[i] + u_vec_[idx_W]);
                // double u_E = isEastBoundary? u_vec_[i] : 0.5 * (u_vec_[i] + u_vec_[idx_E]);
                // double v_N = isNorthBoundary? v_vec_[i] : 0.5 * (v_vec_[i] + v_vec_[idx_N]);
                // double v_S = isSouthBoundary? v_vec_[i] : 0.5 * (v_vec_[i] + v_vec_[idx_S]);
                double u_local = u_vec_[i];
                double v_local = v_vec_[i];

                // auto stop = std::chrono::high_resolution_clock::now();
                // auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
                // avgBackgroundCalcTime += duration.count();
                //std::cout << "ForwardEuler: Background Variable Calc Time: " << duration.count() << "ns" << std::endl;
                // start = std::chrono::high_resolution_clock::now();
                double phi_N, phi_S, phi_W, phi_E;

                //Unraveling any of these if's into single liners hurts performance
                //Killing the branching completely into 1 statement (not possible) only results in ~10% speedup (not worth it)
                //Using only first order upwind can result in a ~40% speedup of the total advection calc.
                //So... there is significantly more cost from actually doing the calculation than from branching.
                if(isNorthBoundary){
                    phi_N = point.bcVal();
                }
                else if (v_local >= 0){
                    phi_N = phi_[i] + 0.5 * minmod_N_vPos(i) * (phi_[idx_N] - phi_[i]);
                }
                else {
                    phi_N = phi_[idx_N] + 0.5 * minmod_N_vNeg(i) * (phi_[i] - phi_[idx_N]);
                }
                if(isSouthBoundary){
                    phi_S = point.bcVal();
                }
                else if (v_local >= 0){
                    phi_S = phi_[idx_S] +  0.5 * minmod_S_vPos(i) * (phi_[i] - phi_[idx_S]);
                }
                else {
                    phi_S = phi_[i] +  0.5 * minmod_S_vNeg(i) * (phi_[idx_S] - phi_[i]);
                }

                if(isWestBoundary){
                    phi_W = secondaryWestBound ? point.secondBoundaryConds().value().bcVal : point.bcVal();
                }
                else if (u_local >= 0){
                    phi_W = phi_[idx_W] + 0.5 * minmod_W_vPos(i) * (phi_[i] - phi_[idx_W]);
                }
                else {
                    phi_W = phi_[i] + 0.5 * minmod_W_vNeg(i) * (phi_[idx_W] - phi_[i]);
                }

                if(isEastBoundary){
                    phi_E = secondaryEastBound ? point.secondBoundaryConds().value().bcVal : point.bcVal();
                }
                else if (u_local >= 0){
                    phi_E = phi_[i] + 0.5 * minmod_E_vPos(i) * (phi_[idx_E] - phi_[i]);
                }
                else {
                    phi_E = phi_[idx_E] + 0.5 * minmod_E_vNeg(i) * (phi_[i] - phi_[idx_E]);
                }

                //std::cout << "ForwardEuler: Fluxes and Update Time: " << duration.count() << "ns" << std::endl;

                //Even just setting this to 0 is like a 2 ns save out of 12, not sure if worth
                soln[i] = /*(!operatorSplit) * (Dh_ * dt_ * invdx_ * (dphi_dx_E - dphi_dx_W) + Dv_ * dt_ * invdy_ * (dphi_dy_N - dphi_dy_S))\*/
                        dt_ * invdx_ * (u_local * phi_W - u_local * phi_E) + dt_ * invdy_ * (v_local * phi_S - v_local * phi_N)\
                        + source_[i] * dt_ + phi_[i];
                // stop = std::chrono::high_resolution_clock::now();
                // duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
                // avgFluxCalcTime += duration.count();
            });
        }
        return soln;
    }
    
void sor_solve(const Eigen::SparseMatrix<double, Eigen::RowMajor> &A, const Eigen::VectorXd &rhs, Eigen::VectorXd &phi, double omega, double threshold, int n_iters) {
    /*
    diagCoeff should always be overwritten in the for loop
    before we get to "x_i *= omega / diagCoeff;"
    Setting it to 0 instead of leaving uninitialized guarantees
    that we get an error if for some reason diagCoeff is not overwritten
    Not sure how to do this better for now...
    */ 
    double diagCoeff = 0;
    double residual = 1;

    while(residual > threshold){
        const double* valuePtr = A.valuePtr();
        const int* innerIdxPtr = A.innerIndexPtr();
        const int* outerIdxPtr = A.outerIndexPtr();

        for(int iteration = 0; iteration < n_iters; iteration++){
            int outerIdx = 0;

            for (int i = 0; i < rhs.size(); i++) {
                double x_i = 0;
                int rowStartIdx = outerIdxPtr[outerIdx];
                int rowEndIdx = outerIdxPtr[outerIdx + 1];
                for (int j = rowStartIdx; j < rowEndIdx; j++) {

                    if (innerIdxPtr[j] == i) {
                        diagCoeff = valuePtr[j];
                        continue;
                    }
                    x_i -= valuePtr[j] * phi[innerIdxPtr[j]];
                }
                x_i += rhs[i];

                x_i *= omega / diagCoeff;
                x_i += (1 - omega) * phi[i];
                phi[i] = x_i;
                outerIdx++;
            } // end inner for loop
        } // end iters for loop
    
        residual = (A * phi - rhs).eval().lpNorm<2>()/ rhs.lpNorm<2>();
        if (isnan(residual)) throw std::runtime_error("NaN residual encountered");
    } // end while loop

}

}